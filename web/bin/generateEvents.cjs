#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const starknet = require("starknet");

// Check for the required arguments
if (process.argv.length !== 4) {
  console.log("Usage: <script> <manifest-path> <output-path>");
  process.exit(1);
}

// Extract paths from command-line arguments
const jsonFilePath = path.resolve(process.argv[2]);
const jsFilePath = path.resolve(process.argv[3]);

// Extract recs package version
const { dependencies } = require(path.resolve("./package.json"));
const recsVersion = dependencies?.["@latticexyz/recs"] ?? "";
const isRecsVersion2 = /^[\^\~]?2./g.exec(recsVersion) != null;
console.log(`...generating for @latticexyz/recs version ${isRecsVersion2 ? '2 (bigint support, Entity as string)' : '1 (no bigint, EntityIndex as number)'}`)

const cairoToRecsType = {
  "bool": "RecsType.Boolean",
  "u8": "RecsType.Number",
  "u16": "RecsType.Number",
  "u32": "RecsType.Number",
  "u64": "RecsType.Number",
  "usize": "RecsType.Number",
  "u128": isRecsVersion2 ? "RecsType.BigInt" : "RecsType.Number",
  "u256": isRecsVersion2 ? "RecsType.BigInt" : "RecsType.NumberArray",
  "felt252": isRecsVersion2 ? "RecsType.BigInt" : "RecsType.Number",
  "ContractAddress": isRecsVersion2 ? "RecsType.String" : "RecsType.String",
}


fs.readFile(jsonFilePath, "utf8", (err, jsonString) => {
  if (err) {
    console.log("Error reading file:", err);
    return;
  }

  try {
    const data = JSON.parse(jsonString);

    let eventsMeta = []

    for (let contract of data.contracts) {
      const events = contract.abi.filter(i => i.type === "event" && i.kind === "struct")

      for (let event of events) {

        const shortName = event.name.substring(event.name.lastIndexOf('::') + 2)
        const selector = "0x" + starknet.hash.starknetKeccak(shortName).toString(16)
        const members = event.members.map(member => {
          const cairoType = member.type.substring(member.type.lastIndexOf('::') + 2)
          return {
            name: member.name,
            cairoType,
            type: cairoToRecsType[cairoType] || "RecsType.String"
          }
        })

        if (eventsMeta.find(i => i.name === shortName)) {
          console.log(`duplicate eventName : ${shortName}`);
        } else {
          eventsMeta.push({
            name: shortName,
            selector,
            members
          })
        }

        // console.log(shortName)
        // console.log(selector)
        // console.log(members)
        // console.log("\n")

      }

    }

    const eventsEnum = `export enum WorldEvents {\n ${eventsMeta.map(e => `${e.name}= "${e.selector}",\n`).join("")
      }};\n\n`

    const eventsData = eventsMeta.map(e => `export interface ${e.name}Data{
      ${e.members.map(m => `${m.name}: ${m.type}`).join('\n')}
      }\n\n`).join("")

    // console.log(eventsEnum)
    // console.log(eventsData)

    let fileContent = `/* Autogenerated file. Do not edit manually. */\n\n`;
    fileContent += `import { Type as RecsType } from "@latticexyz/recs";\n`;
    fileContent += `import { GetTransactionReceiptResponse, Contract } from "starknet";\n\n`;

    fileContent += eventsEnum;
    fileContent += eventsData;

    fs.writeFile(jsFilePath, fileContent, (err) => {
      if (err) {
        console.log("Error writing file:", err);
      } else {
        console.log("File generated successfully");
      }
    });
  } catch (err) {
    console.log("Error parsing JSON string:", err);
  }
});
